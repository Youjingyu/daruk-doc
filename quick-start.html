<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>开始 | Daruk</title>
    <meta name="description" content="daruk 文档">
    <link rel="shortcut icon" href="/daruk-doc/logo.png">
    
    <link rel="preload" href="/daruk-doc/assets/css/0.styles.fc48c779.css" as="style"><link rel="preload" href="/daruk-doc/assets/js/app.2830b220.js" as="script"><link rel="preload" href="/daruk-doc/assets/js/2.3751c7d0.js" as="script"><link rel="preload" href="/daruk-doc/assets/js/11.de64cf99.js" as="script"><link rel="prefetch" href="/daruk-doc/assets/js/10.52e47719.js"><link rel="prefetch" href="/daruk-doc/assets/js/12.b1761f8b.js"><link rel="prefetch" href="/daruk-doc/assets/js/3.80515952.js"><link rel="prefetch" href="/daruk-doc/assets/js/4.78dc510e.js"><link rel="prefetch" href="/daruk-doc/assets/js/5.5818826a.js"><link rel="prefetch" href="/daruk-doc/assets/js/6.0512c878.js"><link rel="prefetch" href="/daruk-doc/assets/js/7.84302fe4.js"><link rel="prefetch" href="/daruk-doc/assets/js/8.8429a461.js"><link rel="prefetch" href="/daruk-doc/assets/js/9.117c7e64.js">
    <link rel="stylesheet" href="/daruk-doc/assets/css/0.styles.fc48c779.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/daruk-doc/" class="home-link router-link-active"><img src="/daruk-doc/logo.png" alt="Daruk" class="logo"> <span class="site-name can-hide">Daruk</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"> <a href="https://github.com/daruk-framework/daruk" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/daruk-framework/daruk" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/daruk-doc/" class="sidebar-link">简介</a></li><li><a href="/daruk-doc/quick-start.html" class="active sidebar-link">开始</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/daruk-doc/quick-start.html#快速使用" class="sidebar-link">快速使用</a></li><li class="sidebar-sub-header"><a href="/daruk-doc/quick-start.html#文件目录结构" class="sidebar-link">文件目录结构</a></li><li class="sidebar-sub-header"><a href="/daruk-doc/quick-start.html#daruk-config" class="sidebar-link">daruk config</a></li><li class="sidebar-sub-header"><a href="/daruk-doc/quick-start.html#project-config" class="sidebar-link">project config</a></li><li class="sidebar-sub-header"><a href="/daruk-doc/quick-start.html#controllers" class="sidebar-link">controllers</a></li><li class="sidebar-sub-header"><a href="/daruk-doc/quick-start.html#middlewares" class="sidebar-link">middlewares</a></li><li class="sidebar-sub-header"><a href="/daruk-doc/quick-start.html#services" class="sidebar-link">services</a></li><li class="sidebar-sub-header"><a href="/daruk-doc/quick-start.html#glues" class="sidebar-link">glues</a></li><li class="sidebar-sub-header"><a href="/daruk-doc/quick-start.html#utils" class="sidebar-link">utils</a></li><li class="sidebar-sub-header"><a href="/daruk-doc/quick-start.html#timers（定时任务）" class="sidebar-link">timers（定时任务）</a></li></ul></li><li><a href="/daruk-doc/decorator.html" class="sidebar-link">装饰器</a></li><li><a href="/daruk-doc/api.html" class="sidebar-link">API</a></li><li><a href="/daruk-doc/lifecycle.html" class="sidebar-link">生命周期</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="content default"><h1 id="开始"><a href="#开始" aria-hidden="true" class="header-anchor">#</a> 开始</h1> <p>我们认为约定目录结构是必要的，约定结构一方面能够统一团队项目结构风格；另一方面，在约定目录结构的基础上，我们能够做自动的 loader 以及初始化，减少模板代码，并且使模块甚至函数级别的性能分析成为可能。另外，装饰器语法能够减少代码量，并能够使代码更加清晰。因此，Daruk 采用了 <code>约定目录结构</code> + <code>装饰器</code> 的基调。</p> <p>Daruk 只是在 Koa 上做了一定的约定并添加了部分方便的功能，所以不管是开发时以及运行时，都和 Koa 相差无几。也正因为此，这篇文档并不会过多地介绍 Koa 的基础概念，需要读者对 Koa 有一定的了解。Daruk 推荐使用 <a href="https://www.tslang.cn/docs/home.html" target="_blank" rel="noopener noreferrer">Typescript<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 来开发，建议先对 Typescript 稍作了解；另外，也建议了解 Typescript 的<a href="https://www.tslang.cn/docs/handbook/decorators.html" target="_blank" rel="noopener noreferrer">装饰器<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，简单来说，装饰器就是一种特殊的语法，它允许我们对类做修改、在类上保存信息，从而提高代码的抽象性，便于管理依赖。</p> <h2 id="快速使用"><a href="#快速使用" aria-hidden="true" class="header-anchor">#</a> 快速使用</h2> <p>使用 <code>Daruk</code> 官方脚手架一键生成项目</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token comment"># 全局安装daurk脚手架</span>
cnpm i -g daruk-cli

<span class="token comment"># 初始化项目</span>
<span class="token comment"># --ignore 表示忽略本地模板缓存</span>
daruk init --ignore daruk-example

<span class="token comment"># 运行项目</span>
<span class="token function">cd</span> daruk-example
<span class="token function">npm</span> run dev
</code></pre></div><h2 id="文件目录结构"><a href="#文件目录结构" aria-hidden="true" class="header-anchor">#</a> 文件目录结构</h2> <p>Daruk使用约定的目录结构来将应用划分为各个部分：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>./daruk-example/src
├── app.ts
├── daruk.config.ts
├── daruk.init.ts
├── config
│   └── index.ts
├── controllers
│   ├── contact
│   │   ├── index.ts
│   │   └── list.ts
│   ├── index.ts
│   └── user.ts
├── middlewares
│   └── koa-test-mid.ts
├── services
│   └── UserInfo.ts
├── glues
│   └── mysql
│       ├── connect.ts
│       └── index.ts
├── timers
│   └── myTimer.ts
├── utils
│   └── index.ts
├── public
│   └── daruk.png
</code></pre></div><p><code>app.ts</code>是应用的入口文件，通常代码如下：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">import</span> daruk <span class="token keyword">from</span> <span class="token string">'./daruk.init.ts'</span>
daruk<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>
</code></pre></div><p>为了在非约定目录能够方便地拿到 daruk 实例，我们通常选择在<code>daruk.init.ts</code>中初始化 daruk，然后在需要的地方能够直接<code>import</code>：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Daruk <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'daruk'</span>
<span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Daruk</span><span class="token punctuation">(</span><span class="token string">'myapp'</span><span class="token punctuation">,</span> options<span class="token punctuation">)</span>
</code></pre></div><p>daruk 继承自 koa，比如有些中间件需要传递 koa 实例作为参数，我们直接传递 daruk 实例即可。</p> <p>除了上述两个文件，剩下的文件和目录都是约定的（非必须），daruk 会主动去加载各个目录下的内容，然后挂载到 daruk 实例或者 koa 的 context 对象上。</p> <p>约定目录中的内容初始化顺序是：<code>config -&gt; daruk.config -&gt; utils -&gt; glues -&gt; services -&gt; middlewares -&gt; controllers -&gt; timers</code></p> <h2 id="daruk-config"><a href="#daruk-config" aria-hidden="true" class="header-anchor">#</a> daruk config</h2> <p><code>daruk.config.ts</code> 是对约定目录的补充，使你能够不通过约定目录，就能向 daruk 挂载内容。通常内容如下：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// src/daruk.config.ts</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> darukConfig<span class="token punctuation">:</span><span class="token builtin">any</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 定义中间件执行顺序</span>
  darukConfig<span class="token punctuation">.</span>middlewareOrder <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'koa2-cors'</span><span class="token punctuation">,</span> <span class="token string">'daurk-test-middleware'</span><span class="token punctuation">]</span>
  <span class="token comment">// 定义中间件</span>
  <span class="token comment">// darukConfig.middleware 对象的 key 即是用在 middlewareOrder 中的中间件名字</span>
  darukConfig<span class="token punctuation">.</span>middleware <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// key 即是中间件包名，也是中间件的名字</span>
    <span class="token comment">// 值为一个函数，函数需要返回中间件的内容</span>
    <span class="token string">'koa2-cors'</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>mid<span class="token punctuation">:</span> <span class="token builtin">Function</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// mid 变量就是通过包名加载到的中间件的内容</span>
      <span class="token keyword">return</span> <span class="token function">mid</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token string">&quot;allowMethods&quot;</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token string">'POST'</span><span class="token punctuation">,</span> <span class="token string">'DELETE'</span><span class="token punctuation">]</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 分别指定中间件的名字和包名</span>
    <span class="token string">'my-middleware'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
      packet<span class="token punctuation">:</span> <span class="token string">'koa-body'</span><span class="token punctuation">,</span>
      <span class="token comment">// 在 export 函数中返回中间件的内容</span>
      <span class="token keyword">export</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>mid<span class="token punctuation">:</span> <span class="token builtin">Function</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">mid</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 直接在 daruk.util、ctx.util 上定义一些方法</span>
  darukConfig<span class="token punctuation">.</span>util <span class="token operator">=</span> <span class="token punctuation">{</span>
		<span class="token string">&quot;testUtil&quot;</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 直接定义定时器配置</span>
  darukConfig<span class="token punctuation">.</span>timer <span class="token operator">=</span> <span class="token punctuation">{</span>
    testTimer<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 最后需要 return 配置</span>
  <span class="token keyword">return</span> darukConfig
<span class="token punctuation">}</span>

</code></pre></div><h2 id="project-config"><a href="#project-config" aria-hidden="true" class="header-anchor">#</a> project config</h2> <p><code>config</code> 目录用于定义项目的配置，config 目录中的 index.ts 需要导出一个函数，函数的参数是 daruk 实例，函数的返回值就是项目的配置，然后就可以在各个地方通过 <code>daruk.config</code>、<code>ctx.config</code> 访问了。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// src/config/index.ts</span>

<span class="token comment">// 其他内容省略...</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>daruk<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> config
<span class="token punctuation">}</span>
</code></pre></div><h2 id="controllers"><a href="#controllers" aria-hidden="true" class="header-anchor">#</a> controllers</h2> <p>很多情况下，路由的存在是为了将请求映射到 controller 层处理，因此我们采用了 controller 定义即路由定义的约定。daruk 会递归读取 controllers 目录下的文件，以文件名作为路由 path，特别的，<code>index.ts</code> 代表的 path 是 <code>/</code>，然后再配合装饰器来定义路由的 http method。所有的 controller 文件都需要导出 Daruk.BaseController 的子类，在该类中可以通过 this.app 访问 daurk 实例，通过 this.ctx 访问 context。</p> <p>比如我们添加一个 <code>GET /contact/list</code> 路由：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// src/controllers/contact/list.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> BaseController<span class="token punctuation">,</span> <span class="token keyword">get</span><span class="token punctuation">,</span> Context <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'daruk'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">ContactList</span> <span class="token keyword">extends</span> <span class="token class-name">BaseController</span> <span class="token punctuation">{</span>
  @<span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
  <span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token function">getContactList</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">:</span> Context<span class="token punctuation">,</span> next<span class="token punctuation">:</span> <span class="token builtin">Function</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token string">'contact list'</span>
    <span class="token keyword">return</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>所有的 http method 都有对应的装饰器，比如 <code>@get</code>、<code>@post</code>、<code>@put</code>、<code>@options</code> 等。</p> <p>路由装饰器可以接受一个字符串参数，用于进一步指定路由的 path，比如要实现上面的 <code>GET /contact/list</code> 路由，我们可以这样写：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// 注意，删除了 src/controllers/contact 目录，直接在 contact.ts 中定义路由</span>
<span class="token comment">// scr/controllers/contact.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> BaseController<span class="token punctuation">,</span> <span class="token keyword">get</span><span class="token punctuation">,</span> Context <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'daruk'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Contact</span> <span class="token keyword">extends</span> <span class="token class-name">BaseController</span> <span class="token punctuation">{</span>
  @<span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/list'</span><span class="token punctuation">)</span>
  <span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token function">getContactList</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">:</span> Context<span class="token punctuation">,</span> next<span class="token punctuation">:</span> <span class="token builtin">Function</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token string">'contact list'</span>
    <span class="token keyword">return</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>另外需要注意，每次用户请求时，对应的 controller 都会实例化，因此不要在 controller 类的 constructor 中执行复杂操作。 其实一般不需要定义 constructor，如果定义了，必须像下面这样执行 super：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// scr/controllers/contact.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> BaseController<span class="token punctuation">,</span> <span class="token keyword">get</span><span class="token punctuation">,</span> Context <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'daruk'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Contact</span> <span class="token keyword">extends</span> <span class="token class-name">BaseController</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">constructor</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">:</span> Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="middlewares"><a href="#middlewares" aria-hidden="true" class="header-anchor">#</a> middlewares</h2> <p>daruk 会以 middlewares 目录下的第一级文件夹名字或者文件名作为 middleware 的名字（middleware的名字用于在 middlewareOrder 中定义中间件执行顺序）。比如通过下面的目录结构，会得到 middleware1、middleware2 两个中间件。注意，文件夹里，需要存在 index.ts 文件。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>middlewares
├── middleware1.ts
├── middleware2
<span class="token operator">|</span>   ├── index.ts
<span class="token operator">|</span>   ├── someLogic.ts
</code></pre></div><p>中间件<code>文件</code>或者<code>文件夹</code>中的 index.ts 需要导出一个函数，函数的参数是 daruk 实例，函数的返回值就是中间件的内容：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// middlewares/middleware1.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Daruk<span class="token punctuation">,</span> Context <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'daruk'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>daruk<span class="token punctuation">:</span> Daruk<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">:</span> Context<span class="token punctuation">,</span> next<span class="token punctuation">:</span> <span class="token builtin">Function</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// do something</span>
    <span class="token keyword">return</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="中间件的使用"><a href="#中间件的使用" aria-hidden="true" class="header-anchor">#</a> 中间件的使用</h3> <p>在注册中间件后，我们需要用 <code>middlewareOrder</code> 声明中间件的调用顺序<br>
中间件注册后不一定会被使用，只有在 <code>middlewareOrder</code> 中声明的中间件才会被调用</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// src/daruk.config.ts</span>
<span class="token keyword">module</span><span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> globalConfig<span class="token punctuation">:</span><span class="token builtin">any</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  globalConfig<span class="token punctuation">.</span>middlewareOrder <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token string">'middleware1'</span><span class="token punctuation">,</span>
    <span class="token string">'middleware2'</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span>

  <span class="token keyword">return</span> globalConfig
<span class="token punctuation">}</span>
</code></pre></div><h2 id="services"><a href="#services" aria-hidden="true" class="header-anchor">#</a> services</h2> <p>简单来说，Service 就是在复杂业务场景下用于做业务逻辑封装的一个抽象层，提供这个抽象有以下几个好处：</p> <ul><li>保持 Controller 中的逻辑更加简洁。</li> <li>保持业务逻辑的独立性，抽象出来的 Service 可以被多个 Controller 重复调用。</li> <li>将逻辑和展现分离，更容易编写测试用例。</li></ul> <p>使用场景：</p> <ul><li>复杂数据的处理，比如要展现的信息需要从数据库获取，还要经过一定的规则计算，才能返回用户显示。或者计算完成后，更新到数据库。</li> <li>第三方服务的调用，比如 处理ioredis等。</li></ul> <p>与 middleware 类似，daruk 也会以 services 目录下的第一级文件夹名字或者文件名作为 service 的名字。比如通过下面的目录结构会得到 service1、service2 两个 service。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>services
├── service1.ts
├── service2
<span class="token operator">|</span>   ├── index.ts
<span class="token operator">|</span>   ├── someLogic.ts
</code></pre></div><p>service <code>文件</code>或者<code>文件夹</code>中的 index.ts 需要导出 Daruk.BaseService 的子类，在该类中可以通过 this.app 访问 daurk 实例，通过 this.ctx 访问 context：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// src/services/userInfo.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> BaseService <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'daruk'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">UserInfo</span> <span class="token keyword">extends</span> <span class="token class-name">BaseService</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token function">getUserList</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> mysql <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>ctx<span class="token punctuation">.</span>glue
    <span class="token keyword">return</span> mysql<span class="token punctuation">.</span><span class="token function">queryUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="service-的使用"><a href="#service-的使用" aria-hidden="true" class="header-anchor">#</a> service 的使用</h3> <p>service 会以遍历到的文件夹或文件名作为 key 自动挂载到 ctx.service 上。</p> <p>注意，只能通过 ctx.service 访问 service，不能通过 daruk.service 访问，因为 service 应该是和请求链路绑定的，只能在请求链路中调用，通常是在 controller 中调用，如果没有请求到达服务器，不应该手动调用 service。</p> <p>在 controller 中使用 service：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// src/controllers/user.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> BaseController<span class="token punctuation">,</span> <span class="token keyword">get</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'daruk'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">extends</span> <span class="token class-name">BaseController</span> <span class="token punctuation">{</span>
  @<span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
  <span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token function">index</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> userInfo <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>ctx<span class="token punctuation">.</span>service
    <span class="token comment">// do something</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>另外需要注意，每次用户请求时，被调用的 service 都会实例化，因此不要在 service 类的 constructor 中执行复杂操作。 其实一般不需要定义 constructor，如果定义了，必须像下面这样执行 super：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// src/controllers/user.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> BaseController<span class="token punctuation">,</span>  Context<span class="token punctuation">,</span> <span class="token keyword">get</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'daruk'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">extends</span> <span class="token class-name">BaseController</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">constructor</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">:</span> Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="glues"><a href="#glues" aria-hidden="true" class="header-anchor">#</a> glues</h2> <p>不管 middleware、controller 或者是 service，都是与用户的访问链路相关的，但我们希望做一些与链路无关的操作，比如连接数据库、进程退出报警等操作。这些操作可以选择放到 glues 目录。</p> <p>glues 目录的扫描规则和 middlewares、services 目录相同，以第一级目录的文件名或者目录名作为 key，将 glues 导出的内容挂载到 daruk.glue 和 ctx.glue 上。比如下面的目录结构会得到 <code>daruk.glue.mysql</code>、<code>ctx.glue.mysql</code></p> <div class="language-bash extra-class"><pre class="language-bash"><code>── glues
<span class="token operator">|</span>	├── mysql
│   ├── index.ts
│   ├── connect.ts
</code></pre></div><p>glues 目录下的文件或者文件夹中的 index.ts 需要导出一个函数，函数的返回值就是 glues 的内容，函数的参数是 daruk 实例：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// src/glues/mysql/index.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Daruk <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'daruk'</span>
<span class="token keyword">import</span> mysql <span class="token keyword">from</span> <span class="token string">'./connect'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>daruk<span class="token punctuation">:</span> Daruk<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> mysql
<span class="token punctuation">}</span>
</code></pre></div><h2 id="utils"><a href="#utils" aria-hidden="true" class="header-anchor">#</a> utils</h2> <p>utils 目录用于定义一些工具方法，daurk 会挂载 utils 到 daurk.util 和 ctx.util。daurk 不限制 utils 的目录结构，只需要在 index.ts 导出 utils 的内容就行了。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// src/utils/index.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Daruk <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'daruk'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>daruk<span class="token punctuation">:</span> Daruk<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> utils
<span class="token punctuation">}</span>
</code></pre></div><h2 id="timers（定时任务）"><a href="#timers（定时任务）" aria-hidden="true" class="header-anchor">#</a> timers（定时任务）</h2> <p>在实际应用中，我们有很多时候需要依赖定时任务来解决问题，例如：</p> <ol><li>定时检测机器状态，性能</li> <li>定时更新缓存</li></ol> <p>类似的，daurk 会以 timers 下文件夹名字或者文件的名字作为 timer 的名字。文件或者文件夹中的 index.ts 需要导出一个函数，函数的参数是 daruk 实例，函数需要返回 timer 的配置：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
      cronTime<span class="token punctuation">:</span> <span class="token string">'* * * * * *'</span><span class="token punctuation">,</span> <span class="token comment">//一秒一次</span>
      <span class="token comment">// 定时器触发的回调</span>
      onTick<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 可以手动停止定时器</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token comment">// 定时器完成的回调</span>
      onComplete<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在你已经可以使用 Daruk 快速搭建一个应用了，接下来可以阅读以下文档：</p> <p><a href="/daruk-doc/decorator.html">Daruk 装饰器</a><br> <a href="/daruk-doc/api.html">Daruk API 文档</a><br> <a href="/daruk-doc/lifecycle.html">Daruk 生命周期</a><br> <a href="/daruk-doc/performance/performance.html">Daruk 性能监控文档</a><br> <a href="/daruk-doc/performance/stress_testing.html">Daruk 压测报告</a></p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/daruk-framework/daruk/edit/master/docs/quick-start.md" target="_blank" rel="noopener noreferrer">Edit this page</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/daruk-doc/" class="prev router-link-active">
          简介
        </a></span> <span class="next"><a href="/daruk-doc/decorator.html">
          装饰器
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/daruk-doc/assets/js/app.2830b220.js" defer></script><script src="/daruk-doc/assets/js/2.3751c7d0.js" defer></script><script src="/daruk-doc/assets/js/11.de64cf99.js" defer></script>
  </body>
</html>
